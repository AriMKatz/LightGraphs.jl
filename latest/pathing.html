<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Path and Traversal · LightGraphs</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>LightGraphs</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Getting Started</a></li><li><a class="toctext" href="graphtypes.html">Choosing A Graph Type</a></li><li><a class="toctext" href="types.html">LightGraphs Types</a></li><li><a class="toctext" href="basicproperties.html">Accessing Properties</a></li><li><a class="toctext" href="generators.html">Making and Modifying Graphs</a></li><li><a class="toctext" href="persistence.html">Reading / Writing Graphs</a></li><li><a class="toctext" href="operators.html">Operators</a></li><li><a class="toctext" href="plotting.html">Plotting Graphs</a></li><li class="current"><a class="toctext" href="pathing.html">Path and Traversal</a><ul class="internal"><li><a class="toctext" href="#Graph-Traversal-1">Graph Traversal</a></li><li><a class="toctext" href="#Random-walks-1">Random walks</a></li><li><a class="toctext" href="#Connectivity-/-Bipartiteness-1">Connectivity / Bipartiteness</a></li><li><a class="toctext" href="#Cycle-Detection-1">Cycle Detection</a></li><li><a class="toctext" href="#Minimum-Spanning-Trees-(MST)-Algorithms-1">Minimum Spanning Trees (MST) Algorithms</a></li><li><a class="toctext" href="#Shortest-Path-Algorithms-1">Shortest-Path Algorithms</a></li><li><a class="toctext" href="#Path-discovery-/-enumeration-1">Path discovery / enumeration</a></li></ul></li><li><a class="toctext" href="distance.html">Distance</a></li><li><a class="toctext" href="centrality.html">Centrality Measures</a></li><li><a class="toctext" href="linalg.html">Linear Algebra</a></li><li><a class="toctext" href="matching.html">Matching</a></li><li><a class="toctext" href="community.html">Community Structures</a></li><li><a class="toctext" href="degeneracy.html">Degeneracy</a></li><li><a class="toctext" href="integration.html">Integration with other packages</a></li><li><a class="toctext" href="experimental.html">Experimental Functionality</a></li><li><a class="toctext" href="parallel.html">Parallel Algorithms</a></li><li><a class="toctext" href="contributing.html">Contributing</a></li><li><a class="toctext" href="developing.html">Developer Notes</a></li><li><a class="toctext" href="license.html">License Information</a></li><li><a class="toctext" href="citing.html">Citing LightGraphs</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="pathing.html">Path and Traversal</a></li></ul><a class="edit-page" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/master/docs/src/pathing.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Path and Traversal</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Path-and-Traversal-1" href="#Path-and-Traversal-1">Path and Traversal</a></h1><p><em>LightGraphs.jl</em> provides several traversal and shortest-path algorithms, along with various utility functions. Where appropriate, edge distances may be passed in as a matrix of real number values.</p><p>Edge distances for most traversals may be passed in as a sparse or dense matrix of  values, indexed by <code>[src,dst]</code> vertices. That is, <code>distmx[2,4] = 2.5</code> assigns the distance <code>2.5</code> to the (directed) edge connecting vertex 2 and vertex 4. Note that also for undirected graphs <code>distmx[4,2]</code> has to be set.</p><p>Default edge distances may be passed in via the</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.DefaultDistance" href="#LightGraphs.DefaultDistance"><code>LightGraphs.DefaultDistance</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">DefaultDistance</code></pre><p>An array-like structure that provides distance values of <code>1</code> for any <code>src, dst</code> combination.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/328d9237d720f66409c58ef2ccbc2ad6065dd675/src/distance.jl#L3-L7">source</a></section><p>structure.</p><p>Any graph traversal  will traverse an edge only if it is present in the graph. When a distance matrix is passed in,</p><ol><li>distance values for undefined edges will be ignored, and</li><li>any unassigned values (in sparse distance matrices), for edges that are present in the graph, will be assumed to take the default value of 1.0.</li><li>any zero values (in sparse/dense distance matrices), for edges that are present in the graph, will instead have an implicit edge cost of 1.0.</li></ol><h2><a class="nav-anchor" id="Graph-Traversal-1" href="#Graph-Traversal-1">Graph Traversal</a></h2><p><em>Graph traversal</em> refers to a process that traverses vertices of a graph following certain order (starting from user-input sources). This package implements three traversal schemes:</p><ul><li><code>BreadthFirst</code>,</li><li><code>DepthFirst</code>, and</li><li><code>MaximumAdjacency</code>.</li></ul><pre><code class="language-none">bfs_tree
LightGraphs.bfs_tree!
dfs_tree
maximum_adjacency_visit
bfs_parents
has_path
diffusion
diffusion_rate
mincut</code></pre><h2><a class="nav-anchor" id="Random-walks-1" href="#Random-walks-1">Random walks</a></h2><p><em>LightGraphs</em> includes uniform random walks and self avoiding walks:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.randomwalk" href="#LightGraphs.randomwalk"><code>LightGraphs.randomwalk</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">randomwalk(g, s, niter)</code></pre><p>Perform a random walk on graph <code>g</code> starting at vertex <code>s</code> and continuing for a maximum of <code>niter</code> steps. Return a vector of vertices visited in order.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/328d9237d720f66409c58ef2ccbc2ad6065dd675/src/traversals/randomwalks.jl#L1-L6">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.non_backtracking_randomwalk" href="#LightGraphs.non_backtracking_randomwalk"><code>LightGraphs.non_backtracking_randomwalk</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">non_backtracking_randomwalk(g, s, niter)</code></pre><p>Perform a non-backtracking random walk on directed graph <code>g</code> starting at vertex <code>s</code> and continuing for a maximum of <code>niter</code> steps. Return a vector of vertices visited in order.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/328d9237d720f66409c58ef2ccbc2ad6065dd675/src/traversals/randomwalks.jl#L23-L29">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.saw" href="#LightGraphs.saw"><code>LightGraphs.saw</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">saw(g, s, niter)</code></pre><p>Perform a <a href="https://en.wikipedia.org/wiki/Self-avoiding_walk">self-avoiding walk</a> on graph <code>g</code> starting at vertex <code>s</code> and continuing for a maximum of <code>niter</code> steps. Return a vector of vertices visited in order.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/328d9237d720f66409c58ef2ccbc2ad6065dd675/src/traversals/randomwalks.jl#L92-L97">source</a></section><h2><a class="nav-anchor" id="Connectivity-/-Bipartiteness-1" href="#Connectivity-/-Bipartiteness-1">Connectivity / Bipartiteness</a></h2><p><code>Graph connectivity</code> functions are defined on both undirected and directed graphs:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.is_connected" href="#LightGraphs.is_connected"><code>LightGraphs.is_connected</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">is_connected(g)</code></pre><p>Return <code>true</code> if graph <code>g</code> is connected. For directed graphs, return <code>true</code> if graph <code>g</code> is weakly connected.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/328d9237d720f66409c58ef2ccbc2ad6065dd675/src/connectivity.jl#L91-L96">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.is_strongly_connected" href="#LightGraphs.is_strongly_connected"><code>LightGraphs.is_strongly_connected</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">is_strongly_connected(g)</code></pre><p>Return <code>true</code> if directed graph <code>g</code> is strongly connected.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/328d9237d720f66409c58ef2ccbc2ad6065dd675/src/connectivity.jl#L215-L219">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.is_weakly_connected" href="#LightGraphs.is_weakly_connected"><code>LightGraphs.is_weakly_connected</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">is_weakly_connected(g)</code></pre><p>Return <code>true</code> if the graph <code>g</code> is weakly connected. If <code>g</code> is undirected, this function is equivalent to <code>is_connected(g)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/328d9237d720f66409c58ef2ccbc2ad6065dd675/src/connectivity.jl#L111-L116">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.connected_components" href="#LightGraphs.connected_components"><code>LightGraphs.connected_components</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">connected_components(g)</code></pre><p>Return the <a href="https://en.wikipedia.org/wiki/Connectivity_(graph_theory)">connected components</a> of an undirected graph <code>g</code> as a vector of components, with each element a vector of vertices belonging to the component.</p><p>For directed graphs, see <a href="pathing.html#LightGraphs.strongly_connected_components"><code>strongly_connected_components</code></a> and <a href="pathing.html#LightGraphs.weakly_connected_components"><code>weakly_connected_components</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/328d9237d720f66409c58ef2ccbc2ad6065dd675/src/connectivity.jl#L74-L83">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.strongly_connected_components" href="#LightGraphs.strongly_connected_components"><code>LightGraphs.strongly_connected_components</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">strongly_connected_components(g)</code></pre><p>Compute the strongly connected components of a directed graph <code>g</code>.</p><p>Return an array of arrays, each of which is the entire connected component.</p><p><strong>Implementation Notes</strong></p><p>The order of the components is not part of the API contract.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/328d9237d720f66409c58ef2ccbc2ad6065dd675/src/connectivity.jl#L119-L128">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.weakly_connected_components" href="#LightGraphs.weakly_connected_components"><code>LightGraphs.weakly_connected_components</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">weakly_connected_components(g)</code></pre><p>Return the weakly connected components of the graph <code>g</code>. This is equivalent to the connected components of the undirected equivalent of <code>g</code>. For undirected graphs this is equivalent to the connected components of <code>g</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/328d9237d720f66409c58ef2ccbc2ad6065dd675/src/connectivity.jl#L102-L108">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.has_self_loops" href="#LightGraphs.has_self_loops"><code>LightGraphs.has_self_loops</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">has_self_loops(g)</code></pre><p>Return true if <code>g</code> has any self loops.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/328d9237d720f66409c58ef2ccbc2ad6065dd675/src/core.jl#L168-L172">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.attracting_components" href="#LightGraphs.attracting_components"><code>LightGraphs.attracting_components</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">attracting_components(g)</code></pre><p>Return a vector of vectors of integers representing lists of attracting components in the directed graph <code>g</code>.</p><p>The attracting components are a subset of the strongly connected components in which the components do not have any leaving edges.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/328d9237d720f66409c58ef2ccbc2ad6065dd675/src/connectivity.jl#L279-L287">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.is_bipartite" href="#LightGraphs.is_bipartite"><code>LightGraphs.is_bipartite</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">is_bipartite(g)</code></pre><p>Return <code>true</code> if graph <code>g</code> is <a href="https://en.wikipedia.org/wiki/Bipartite_graph">bipartite</a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/328d9237d720f66409c58ef2ccbc2ad6065dd675/src/traversals/bipartition.jl#L42-L46">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.bipartite_map" href="#LightGraphs.bipartite_map"><code>LightGraphs.bipartite_map</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bipartite_map(g)</code></pre><p>For a bipartite graph <code>g</code>, return a vector <code>c</code> of size <span>$|V|$</span> containing the assignment of each vertex to one of the two sets (<span>$c_i == 1$</span> or c_i == 2`<code>). If</code>g` is not bipartite, return an empty vector.</p><p><strong>Implementation Notes</strong></p><p>Note that an empty vector does not necessarily indicate non-bipartiteness. An empty graph will return an empty vector but is bipartite.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/328d9237d720f66409c58ef2ccbc2ad6065dd675/src/traversals/bipartition.jl#L1-L11">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.biconnected_components" href="#LightGraphs.biconnected_components"><code>LightGraphs.biconnected_components</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">biconnected_components(g)</code></pre><p>Compute the <a href="https://en.wikipedia.org/wiki/Biconnected_component">biconnected components</a> of an undirected graph <code>g</code>and return a vector of vectors containing each biconnected component.</p><p>Performance: Time complexity is <span>$\mathcal{O}(|V|)$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/328d9237d720f66409c58ef2ccbc2ad6065dd675/src/biconnectivity/biconnect.jl#L56-L65">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.condensation" href="#LightGraphs.condensation"><code>LightGraphs.condensation</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">condensation(g[, scc])</code></pre><p>Return the condensation graph of the strongly connected components <code>scc</code> in the directed graph <code>g</code>. If <code>scc</code> is missing, generate the strongly connected components first.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/328d9237d720f66409c58ef2ccbc2ad6065dd675/src/connectivity.jl#L252-L258">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.neighborhood" href="#LightGraphs.neighborhood"><code>LightGraphs.neighborhood</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">neighborhood(g, v, d, distmx=weights(g))</code></pre><p>Return a vector of each vertex in <code>g</code> at a geodesic distance less than or equal to <code>d</code>, where distances may be specified by <code>distmx</code>. </p><p><strong>Optional Arguments</strong></p><ul><li><code>dir=:out</code>: If <code>g</code> is directed, this argument specifies the edge direction</li></ul><p>with respect to <code>v</code> of the edges to be considered. Possible values: <code>:in</code> or <code>:out</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/328d9237d720f66409c58ef2ccbc2ad6065dd675/src/connectivity.jl#L304-L314">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.neighborhood_dists" href="#LightGraphs.neighborhood_dists"><code>LightGraphs.neighborhood_dists</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">neighborhood_dists(g, v, d, distmx=weights(g))</code></pre><p>Return a tuple of each vertex at a geodesic distance less than or equal to <code>d</code>, where distances may be specified by <code>distmx</code>, along with its distance from <code>v</code>.</p><p><strong>Optional Arguments</strong></p><ul><li><code>dir=:out</code>: If <code>g</code> is directed, this argument specifies the edge direction</li></ul><p>with respect to <code>v</code> of the edges to be considered. Possible values: <code>:in</code> or <code>:out</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/328d9237d720f66409c58ef2ccbc2ad6065dd675/src/connectivity.jl#L318-L327">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.articulation" href="#LightGraphs.articulation"><code>LightGraphs.articulation</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">articulation(g)</code></pre><p>Compute the <a href="https://en.wikipedia.org/wiki/Biconnected_component">articulation points</a> of a connected graph <code>g</code> and return an array containing all cut vertices.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/328d9237d720f66409c58ef2ccbc2ad6065dd675/src/biconnectivity/articulation.jl#L51-L56">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.period" href="#LightGraphs.period"><code>LightGraphs.period</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">period(g)</code></pre><p>Return the (common) period for all vertices in a strongly connected directed graph. Will throw an error if the graph is not strongly connected.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/328d9237d720f66409c58ef2ccbc2ad6065dd675/src/connectivity.jl#L223-L228">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.isgraphical" href="#LightGraphs.isgraphical"><code>LightGraphs.isgraphical</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isgraphical(degs)</code></pre><p>Return true if the degree sequence <code>degs</code> is graphical, according to <a href="http://mathworld.wolfram.com/GraphicSequence.html">Erdös-Gallai condition</a>.</p><p><strong>Performance</strong></p><pre><code class="language-none">Time complexity: ``\mathcal{O}(|degs|^2)``</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/328d9237d720f66409c58ef2ccbc2ad6065dd675/src/connectivity.jl#L361-L369">source</a></section><h2><a class="nav-anchor" id="Cycle-Detection-1" href="#Cycle-Detection-1">Cycle Detection</a></h2><p>In graph theory, a cycle is defined to be a path that starts from some vertex <code>v</code> and ends up at <code>v</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.is_cyclic" href="#LightGraphs.is_cyclic"><code>LightGraphs.is_cyclic</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">is_cyclic(g)</code></pre><p>Return <code>true</code> if graph <code>g</code> contains a cycle.</p><p><strong>Implementation Notes</strong></p><p>Uses DFS.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/328d9237d720f66409c58ef2ccbc2ad6065dd675/src/traversals/dfs.jl#L4-L11">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.maxsimplecycles" href="#LightGraphs.maxsimplecycles"><code>LightGraphs.maxsimplecycles</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">maxsimplecycles(dg::::IsDirected, byscc::Bool = true)</code></pre><p>Compute the theoretical maximum number of cycles in the directed graph <code>dg</code>.</p><p>The computation can be performed assuming the graph is complete or taking into account the decomposition in strongly connected components (<code>byscc</code> parameter).</p><p><strong>Performance</strong></p><p>A more efficient version is possible.</p><p><strong>References</strong></p><ul><li><a href="http://epubs.siam.org/doi/abs/10.1137/0204007">Johnson</a></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/328d9237d720f66409c58ef2ccbc2ad6065dd675/src/cycles/johnson.jl#L24-L37">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.simplecycles" href="#LightGraphs.simplecycles"><code>LightGraphs.simplecycles</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">simplecycles(dg::::IsDirected)</code></pre><p>Compute and return all cycles of the given directed graph using Johnson&#39;s algorithm.</p><p><strong>Performance</strong></p><p>The number of cycles grows more than exponentially with the number of vertices, you might want to use the algorithm with a ceiling – <code>getcycles</code> – on large directed graphs (slightly slower). If you want to have an idea of the possible number of cycles, look at function <code>maxsimplecycles(dg::DiGraph, byscc::Bool = true)</code>.</p><p><strong>References</strong></p><ul><li><a href="http://epubs.siam.org/doi/abs/10.1137/0204007">Johnson</a></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/328d9237d720f66409c58ef2ccbc2ad6065dd675/src/cycles/johnson.jl#L156-L169">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.simplecycles_iter" href="#LightGraphs.simplecycles_iter"><code>LightGraphs.simplecycles_iter</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">simplecycles_iter(dg::DiGraph, ceiling = 10^6)</code></pre><p>Search all cycles of the given directed graph, using Johnson&#39;s algorithm, up to the ceiling (to avoid memory overload).</p><p><strong>Implementation Notes</strong></p><p>If the graph is small, the ceiling will not be reached and <code>simplecycles(dg::DiGraph)</code> is more efficient. It avoids the overhead of the counting and testing if the ceiling is reached. It returns all the cycles of the directed graph if the <code>ceiling</code> is not reached, a subset of them otherwise.</p><p>To get an idea of the possible number of cycles, use function `maxsimplecycles(dg::DiGraph, byscc::Bool = true) on the directed graph.</p><p><strong>References</strong></p><ul><li><a href="http://epubs.siam.org/doi/abs/10.1137/0204007">Johnson</a></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/328d9237d720f66409c58ef2ccbc2ad6065dd675/src/cycles/johnson.jl#L290-L307">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.simplecycles_hadwick_james" href="#LightGraphs.simplecycles_hadwick_james"><code>LightGraphs.simplecycles_hadwick_james</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">simplecycles_hadwick_james(g)</code></pre><p>Find circuits (including self-loops) in <code>g</code> using the algorithm of Hadwick &amp; James.</p><p><strong>References</strong></p><ul><li>Hadwick &amp; James, &quot;Enumerating Circuits and Loops in Graphs with Self-Arcs and Multiple-Arcs&quot;, 2008</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/328d9237d720f66409c58ef2ccbc2ad6065dd675/src/cycles/hadwick-james.jl#L1-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.simplecyclescount" href="#LightGraphs.simplecyclescount"><code>LightGraphs.simplecyclescount</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">simplecyclescount(dg::DiGraph, ceiling = 10^6)</code></pre><p>Count the number of cycles in a directed graph, using Johnson&#39;s algorithm. Return the minimum of the ceiling and the number of cycles.</p><p><strong>Implementation Notes</strong></p><p>The <code>ceiling</code> is here to avoid memory overload if there are a lot of cycles in the graph. Default value is 10^6, but it can be higher or lower. You can use the function <code>maxsimplecycles(dg::DiGraph, byscc::Bool = true)</code> to get an idea of the theoretical maximum number or cycles.</p><p><strong>References</strong></p><ul><li><a href="http://epubs.siam.org/doi/abs/10.1137/0204007">Johnson</a></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/328d9237d720f66409c58ef2ccbc2ad6065dd675/src/cycles/johnson.jl#L266-L280">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.simplecycleslength" href="#LightGraphs.simplecycleslength"><code>LightGraphs.simplecycleslength</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">simplecycleslength(dg::DiGraph, ceiling = 10^6)</code></pre><p>Search all cycles of the given directed graph, using Johnson&#39;s algorithm,  and return a tuple representing the cycle length and the number of cycles.</p><p><strong>Implementation Notes</strong></p><p>To get an idea of the possible number of cycles, using function <code>maxsimplecycles(dg::DiGraph, byscc::Bool = true)</code> on the directed graph.</p><p>If the <code>ceiling</code> is reached (<code>ncycles = ceiling</code>), the output is only a subset of the cycles lengths.</p><p><strong>References</strong></p><ul><li><a href="http://epubs.siam.org/doi/abs/10.1137/0204007">Johnson</a></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/328d9237d720f66409c58ef2ccbc2ad6065dd675/src/cycles/johnson.jl#L312-L327">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.karp_minimum_cycle_mean" href="#LightGraphs.karp_minimum_cycle_mean"><code>LightGraphs.karp_minimum_cycle_mean</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">karp_minimum_cycle_mean(g[, distmx])</code></pre><p>Return minimum cycle mean of the directed graph <code>g</code> with optional edge weights contained in <code>distmx</code>.</p><p><strong>References</strong></p><ul><li><a href="http://dx.doi.org/10.1016/0012-365X(78)90011-0">Karp</a>.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/328d9237d720f66409c58ef2ccbc2ad6065dd675/src/cycles/karp.jl#L89-L96">source</a></section><h2><a class="nav-anchor" id="Minimum-Spanning-Trees-(MST)-Algorithms-1" href="#Minimum-Spanning-Trees-(MST)-Algorithms-1">Minimum Spanning Trees (MST) Algorithms</a></h2><p>A Minimum Spanning Tree (MST) is a subset of the edges of a connected, edge-weighted (un)directed graph that connects all the vertices together, without any cycles and with the minimum possible total edge weight.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.kruskal_mst" href="#LightGraphs.kruskal_mst"><code>LightGraphs.kruskal_mst</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">kruskal_mst(g, distmx=weights(g))</code></pre><p>Return a vector of edges representing the minimum spanning tree of a connected, undirected graph <code>g</code> with optional distance matrix <code>distmx</code> using <a href="https://en.wikipedia.org/wiki/Kruskal%27s_algorithm">Kruskal&#39;s algorithm</a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/328d9237d720f66409c58ef2ccbc2ad6065dd675/src/spanningtrees/kruskal.jl#L1-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.prim_mst" href="#LightGraphs.prim_mst"><code>LightGraphs.prim_mst</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">prim_mst(g, distmx=weights(g))</code></pre><p>Return a vector of edges representing the minimum spanning tree of a connected, undirected graph <code>g</code> with optional distance matrix <code>distmx</code> using <a href="https://en.wikipedia.org/wiki/Prim%27s_algorithm">Prim&#39;s algorithm</a>. Return a vector of edges.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/328d9237d720f66409c58ef2ccbc2ad6065dd675/src/spanningtrees/prim.jl#L1-L7">source</a></section><h2><a class="nav-anchor" id="Shortest-Path-Algorithms-1" href="#Shortest-Path-Algorithms-1">Shortest-Path Algorithms</a></h2><h3><a class="nav-anchor" id="General-properties-of-shortest-path-algorithms-1" href="#General-properties-of-shortest-path-algorithms-1">General properties of shortest path algorithms</a></h3><ul><li>The distance from a vertex to itself is always <code>0</code>.</li><li>The distance between two vertices with no connecting edge is always <code>Inf</code>.</li></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.a_star" href="#LightGraphs.a_star"><code>LightGraphs.a_star</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">a_star(g, s, t[, distmx][, heuristic])</code></pre><p>Return a vector of edges comprising the shortest path between vertices <code>s</code> and <code>t</code> using the <a href="http://en.wikipedia.org/wiki/A%2A_search_algorithm">A* search algorithm</a>. An optional heuristic function and edge distance matrix may be supplied. If missing, the distance matrix is set to <a href="pathing.html#LightGraphs.DefaultDistance"><code>LightGraphs.DefaultDistance</code></a> and the heuristic is set to <code>n -&gt; 0</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/328d9237d720f66409c58ef2ccbc2ad6065dd675/src/shortestpaths/astar.jl#L36-L44">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.dijkstra_shortest_paths" href="#LightGraphs.dijkstra_shortest_paths"><code>LightGraphs.dijkstra_shortest_paths</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dijkstra_shortest_paths(g, srcs, distmx=weights(g));</code></pre><p>Perform <a href="http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra&#39;s algorithm</a> on a graph, computing shortest distances between <code>srcs</code> and all other vertices. Return a <a href="pathing.html#LightGraphs.DijkstraState"><code>LightGraphs.DijkstraState</code></a> that contains various traversal information.</p><p><strong>Optional Arguments</strong></p><ul><li><code>allpaths=false</code>: If true, returns a <a href="pathing.html#LightGraphs.DijkstraState"><code>LightGraphs.DijkstraState</code></a> that keeps track of all</li></ul><p>predecessors of a given vertex.</p><p><strong>Performance</strong></p><p>Use a matrix type for <code>distmx</code> that is implemented in <a href="https://en.wikipedia.org/wiki/Row-_and_column-major_order">row-major matrix format</a>  for better run-time. Eg. Set the type of <code>distmx</code> to <code>Transpose{Int64, SparseMatrixCSC{Int64,Int64}}</code>  instead of <code>SparseMatrixCSC{Int64,Int64}</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/328d9237d720f66409c58ef2ccbc2ad6065dd675/src/shortestpaths/dijkstra.jl#L14-L30">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.bellman_ford_shortest_paths" href="#LightGraphs.bellman_ford_shortest_paths"><code>LightGraphs.bellman_ford_shortest_paths</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">bellman_ford_shortest_paths(g, s, distmx=weights(g))
bellman_ford_shortest_paths(g, ss, distmx=weights(g))</code></pre><p>Compute shortest paths between a source <code>s</code> (or list of sources <code>ss</code>) and all other nodes in graph <code>g</code> using the <a href="http://en.wikipedia.org/wiki/Bellman–Ford_algorithm">Bellman-Ford algorithm</a>. Return a <a href="pathing.html#LightGraphs.BellmanFordState"><code>LightGraphs.BellmanFordState</code></a> with relevant traversal information.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/328d9237d720f66409c58ef2ccbc2ad6065dd675/src/shortestpaths/bellman-ford.jl#L26-L33">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.floyd_warshall_shortest_paths" href="#LightGraphs.floyd_warshall_shortest_paths"><code>LightGraphs.floyd_warshall_shortest_paths</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">floyd_warshall_shortest_paths(g, distmx=weights(g))</code></pre><p>Use the <a href="http://en.wikipedia.org/wiki/Floyd–Warshall_algorithm">Floyd-Warshall algorithm</a> to compute the shortest paths between all pairs of vertices in graph <code>g</code> using an optional distance matrix <code>distmx</code>. Return a <a href="pathing.html#LightGraphs.FloydWarshallState"><code>LightGraphs.FloydWarshallState</code></a> with relevant traversal information.</p><p><strong>Performance</strong></p><p>Space complexity is on the order of <span>$\mathcal{O}(|V|^2)$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/328d9237d720f66409c58ef2ccbc2ad6065dd675/src/shortestpaths/floyd-warshall.jl#L13-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.yen_k_shortest_paths" href="#LightGraphs.yen_k_shortest_paths"><code>LightGraphs.yen_k_shortest_paths</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">yen_k_shortest_paths(g, source, target, distmx=weights(g), K=1; maxdist=Inf);</code></pre><p>Perform <a href="http://en.wikipedia.org/wiki/Yen%27s_algorithm">Yen&#39;s algorithm</a> on a graph, computing k-shortest distances between <code>source</code> and <code>target</code> other vertices. Return a <a href="pathing.html#LightGraphs.YenState"><code>YenState</code></a> that contains distances and paths.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/328d9237d720f66409c58ef2ccbc2ad6065dd675/src/shortestpaths/yen.jl#L12-L18">source</a></section><h2><a class="nav-anchor" id="Path-discovery-/-enumeration-1" href="#Path-discovery-/-enumeration-1">Path discovery / enumeration</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.gdistances" href="#LightGraphs.gdistances"><code>LightGraphs.gdistances</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gdistances(g, source; sort_alg=QuickSort)</code></pre><p>Return a vector filled with the geodesic distances of vertices in  <code>g</code> from <code>source</code>. If <code>source</code> is a collection of vertices each element should be unique. For vertices in disconnected components the default distance is <code>typemax(T)</code>.</p><p>An optional sorting algorithm may be specified (see Performance section).</p><p><strong>Performance</strong></p><p><code>gdistances</code> uses <code>QuickSort</code> internally for its default sorting algorithm, since it performs the best of the algorithms built into Julia Base. However, passing a <code>RadixSort</code> (available via <a href="https://github.com/JuliaCollections/SortingAlgorithms.jl">SortingAlgorithms.jl</a>) will provide significant performance improvements on larger graphs.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/328d9237d720f66409c58ef2ccbc2ad6065dd675/src/traversals/bfs.jl#L126-L140">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.gdistances!" href="#LightGraphs.gdistances!"><code>LightGraphs.gdistances!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">gdistances!(g, source, dists; sort_alg=QuickSort)</code></pre><p>Fill <code>dists</code> with the geodesic distances of vertices in <code>g</code> from source vertex (or collection of vertices) <code>source</code>. <code>dists</code> should be a vector of length <code>nv(g)</code>  filled with <code>typemax(T)</code>. Return <code>dists</code>.</p><p>For vertices in disconnected components the default distance is <code>typemax(T)</code>.</p><p>An optional sorting algorithm may be specified (see Performance section).</p><p><strong>Performance</strong></p><p><code>gdistances</code> uses <code>QuickSort</code> internally for its default sorting algorithm, since it performs the best of the algorithms built into Julia Base. However, passing a <code>RadixSort</code> (available via <a href="https://github.com/JuliaCollections/SortingAlgorithms.jl">SortingAlgorithms.jl</a>) will provide significant performance improvements on larger graphs.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/328d9237d720f66409c58ef2ccbc2ad6065dd675/src/traversals/bfs.jl#L78-L94">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.enumerate_paths" href="#LightGraphs.enumerate_paths"><code>LightGraphs.enumerate_paths</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">enumerate_paths(state[, vs])</code></pre><p>Given a path state <code>state</code> of type <code>AbstractPathState</code>, return a vector (indexed by vertex) of the paths between the source vertex used to compute the path state and a single destination vertex, a list of destination vertices, or the entire graph. For multiple destination vertices, each path is represented by a vector of vertices on the path between the source and the destination. Nonexistent paths will be indicated by an empty vector. For single destinations, the path is represented by a single vector of vertices, and will be length 0 if the path does not exist.</p><p><strong>Implementation Notes</strong></p><p>For Floyd-Warshall path states, please note that the output is a bit different, since this algorithm calculates all shortest paths for all pairs of vertices: <code>enumerate_paths(state)</code> will return a vector (indexed by source vertex) of vectors (indexed by destination vertex) of paths. <code>enumerate_paths(state, v)</code> will return a vector (indexed by destination vertex) of paths from source <code>v</code> to all other vertices. In addition, <code>enumerate_paths(state, v, d)</code> will return a vector representing the path from vertex <code>v</code> to vertex <code>d</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/328d9237d720f66409c58ef2ccbc2ad6065dd675/src/shortestpaths/bellman-ford.jl#L90-L110">source</a></section><h3><a class="nav-anchor" id="Path-States-1" href="#Path-States-1">Path States</a></h3><p>All path states derive from</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.AbstractPathState" href="#LightGraphs.AbstractPathState"><code>LightGraphs.AbstractPathState</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractPathState</code></pre><p>An abstract type that provides information from shortest paths calculations.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/328d9237d720f66409c58ef2ccbc2ad6065dd675/src/core.jl#L1-L5">source</a></section><p>The <code>dijkstra_shortest_paths</code>, <code>floyd_warshall_shortest_paths</code>, <code>bellman_ford_shortest_paths</code>, and <code>yen_shortest_paths</code> functions  return states that contain various  information about the graph learned during traversal. </p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.DijkstraState" href="#LightGraphs.DijkstraState"><code>LightGraphs.DijkstraState</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct DijkstraState{T, U}</code></pre><p>An <a href="pathing.html#LightGraphs.AbstractPathState"><code>AbstractPathState</code></a> designed for Dijkstra shortest-paths calculations.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/328d9237d720f66409c58ef2ccbc2ad6065dd675/src/shortestpaths/dijkstra.jl#L1-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.BellmanFordState" href="#LightGraphs.BellmanFordState"><code>LightGraphs.BellmanFordState</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">BellmanFordState{T, U}</code></pre><p>An <code>AbstractPathState</code> designed for Bellman-Ford shortest-paths calculations.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/328d9237d720f66409c58ef2ccbc2ad6065dd675/src/shortestpaths/bellman-ford.jl#L16-L20">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.FloydWarshallState" href="#LightGraphs.FloydWarshallState"><code>LightGraphs.FloydWarshallState</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct FloydWarshallState{T, U}</code></pre><p>An <a href="pathing.html#LightGraphs.AbstractPathState"><code>AbstractPathState</code></a> designed for Floyd-Warshall shortest-paths calculations.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/328d9237d720f66409c58ef2ccbc2ad6065dd675/src/shortestpaths/floyd-warshall.jl#L3-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LightGraphs.YenState" href="#LightGraphs.YenState"><code>LightGraphs.YenState</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct YenState{T, U}</code></pre><p>Designed for yen k-shortest-paths calculations.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphs/LightGraphs.jl/blob/328d9237d720f66409c58ef2ccbc2ad6065dd675/src/shortestpaths/yen.jl#L1-L5">source</a></section><p>The above state types (with the exception of <code>YenState</code>) have the following common information, accessible via the type:</p><p><code>.dists</code> Holds a vector of distances computed, indexed by source vertex.</p><p><code>.parents</code> Holds a vector of parents of each source vertex. The parent of a source vertex is always <code>0</code>.</p><p>(<code>YenState</code> substitutes <code>.paths</code> for <code>.parents</code>.)</p><p>In addition, the following information may be populated with the appropriate arguments to <code>dijkstra_shortest_paths</code>:</p><p><code>.predecessors</code> Holds a vector, indexed by vertex, of all the predecessors discovered during shortest-path calculations. This keeps track of all parents when there are multiple shortest paths available from the source.</p><p><code>.pathcounts</code> Holds a vector, indexed by vertex, of the path counts discovered during traversal. This equals the length of each subvector in the <code>.predecessors</code> output above.</p><footer><hr/><a class="previous" href="plotting.html"><span class="direction">Previous</span><span class="title">Plotting Graphs</span></a><a class="next" href="distance.html"><span class="direction">Next</span><span class="title">Distance</span></a></footer></article></body></html>
